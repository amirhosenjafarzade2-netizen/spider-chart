<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Interactive Alluvial / Sankey Diagram Generator</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f9f9f9; color: #333; }
    h1, h2 { color: #2c3e50; }
    p { max-width: 900px; }
    #editor { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 30px; }
    #nodesList { list-style: none; padding: 0; margin: 10px 0; }
    #nodesList li { margin: 8px 0; padding: 10px; background: #eef5fb; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }
    #nodesList button { background: #e74c3c; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
    #linksTable { border-collapse: collapse; width: 100%; margin: 15px 0; }
    #linksTable th, #linksTable td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    #linksTable th { background: #f0f0f0; }
    #linksTable select, #linksTable input { width: 100%; padding: 6px; }
    #linksTable button { background: #e74c3c; color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
    button.main { margin: 10px 10px 10px 0; padding: 10px 20px; font-size: 16px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 4px; }
    button.main:hover { background: #2980b9; }
    label { margin-right: 20px; }
    #download { margin-top: 20px; text-align: center; }
    #chart { margin-top: 40px; text-align: center; overflow: hidden; }
    .note { font-style: italic; color: #555; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>Interactive Alluvial / Sankey Diagram Generator</h1>
  <p>Add nodes first, then create directed flows between them with values. Node names must be unique.</p>
  <p class="note">For classic alluvial diagrams (e.g., category changes over time), prefix node names with the stage (e.g., "1990-Male", "2000-Male") and only connect nodes between consecutive stages. Use "Justify" alignment for the best layered look.</p>

  <div id="editor">
    <h2>Nodes</h2>
    <label>Add Node: <input type="text" id="newNodeName" placeholder="Enter unique node name">
    <button class="main" onclick="addNode()">Add Node</button></label>
    <ul id="nodesList"></ul>

    <h2>Flows</h2>
    <table id="linksTable">
      <thead>
        <tr>
          <th>Source</th>
          <th>Target</th>
          <th>Value (&gt; 0)</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <button class="main" onclick="addLinkRow()">Add Flow</button>

    <div style="margin-top: 20px;">
      <label for="align">Node alignment:</label>
      <select id="align">
        <option value="Justify" selected>Justify (best for alluvial)</option>
        <option value="Left">Left</option>
        <option value="Right">Right</option>
        <option value="Center">Center (good for classic Sankey)</option>
      </select>

      <button class="main" onclick="loadAlluvialExample()">Load Alluvial Example</button>
      <button class="main" onclick="loadEnergyExample()">Load Energy Example</button>
      <button class="main" onclick="generate()">Generate Diagram</button>
    </div>
  </div>

  <div id="chart"></div>
  <div id="download"></div>

  <script>
    let nodes = [];
    let links = []; // [{source: "A", target: "B", value: 10}, ...]

    function addNode() {
      const input = document.getElementById('newNodeName');
      const name = input.value.trim();
      if (!name) {
        alert("Please enter a node name.");
        return;
      }
      if (nodes.includes(name)) {
        alert("Node name already exists. Names must be unique.");
        return;
      }
      nodes.push(name);
      input.value = "";
      rebuildNodesList();
    }

    function removeNode(index) {
      const removedName = nodes[index];
      nodes.splice(index, 1);
      links = links.filter(l => l.source !== removedName && l.target !== removedName);
      rebuildNodesList();
      rebuildLinksTable();
    }

    function rebuildNodesList() {
      const ul = document.getElementById('nodesList');
      ul.innerHTML = "";
      nodes.forEach((name, i) => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = name;
        const btn = document.createElement('button');
        btn.textContent = "Remove";
        btn.onclick = () => removeNode(i);
        li.appendChild(span);
        li.appendChild(btn);
        ul.appendChild(li);
      });
    }

    function populateSelect(select) {
      select.innerHTML = '<option value="">-- Select --</option>';
      nodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n;
        opt.textContent = n;
        select.appendChild(opt);
      });
    }

    function addLinkRow() {
      if (nodes.length < 2) {
        alert("Add at least 2 nodes before creating flows.");
        return;
      }
      links.push({source: nodes[0], target: nodes[1] || nodes[0], value: 10});
      rebuildLinksTable();
    }

    function removeLink(index) {
      links.splice(index, 1);
      rebuildLinksTable();
    }

    function rebuildLinksTable() {
      const tbody = document.getElementById('linksTable').tBodies[0];
      tbody.innerHTML = "";
      links.forEach((link, i) => {
        const tr = tbody.insertRow();

        // Source
        const tdSource = tr.insertCell();
        const selectSource = document.createElement('select');
        populateSelect(selectSource);
        selectSource.value = link.source;
        selectSource.onchange = () => { links[i].source = selectSource.value; };
        tdSource.appendChild(selectSource);

        // Target
        const tdTarget = tr.insertCell();
        const selectTarget = document.createElement('select');
        populateSelect(selectTarget);
        selectTarget.value = link.target;
        selectTarget.onchange = () => { links[i].target = selectTarget.value; };
        tdTarget.appendChild(selectTarget);

        // Value
        const tdValue = tr.insertCell();
        const inputValue = document.createElement('input');
        inputValue.type = "number";
        inputValue.min = "0";
        inputValue.step = "any";
        inputValue.value = link.value;
        inputValue.oninput = () => { links[i].value = parseFloat(inputValue.value) || 0; };
        tdValue.appendChild(inputValue);

        // Remove
        const tdAction = tr.insertCell();
        const btnRemove = document.createElement('button');
        btnRemove.textContent = "Remove";
        btnRemove.onclick = () => removeLink(i);
        tdAction.appendChild(btnRemove);
      });
    }

    function getAlign() {
      const val = document.getElementById('align').value;
      if (val === "Left") return d3.sankeyLeft;
      if (val === "Right") return d3.sankeyRight;
      if (val === "Center") return d3.sankeyCenter;
      return d3.sankeyJustify;
    }

    function generate() {
      if (nodes.length < 2) {
        alert("Add at least 2 nodes.");
        return;
      }
      if (links.length === 0) {
        alert("Add at least one flow.");
        return;
      }

      // Combine duplicate flows (same source → target)
      const linkMap = {};
      links.forEach(l => {
        if (l.source && l.target && l.source !== l.target && l.value > 0) {
          const key = `${l.source}→${l.target}`;
          linkMap[key] = (linkMap[key] || 0) + l.value;
        }
      });

      const rawLinks = Object.entries(linkMap).map(([key, value]) => {
        const [source, target] = key.split('→');
        return {source, target, value};
      });

      const rawNodes = nodes.map(name => ({name}));

      if (rawLinks.length === 0) {
        alert("No valid flows (check values > 0 and different source/target).");
        return;
      }

      drawDiagram(rawNodes, rawLinks);
      document.getElementById('download').innerHTML = '<button class="main" onclick="downloadPNG()">Download as PNG</button>';
    }

    function drawDiagram(rawNodes, rawLinks) {
      d3.select("#chart svg").remove();

      const width = 1200;
      const height = 800;

      const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .style("max-width", "100%")
        .style("height", "auto");

      const sankey = d3.sankey()
        .nodeId(d => d.name)
        .nodeAlign(getAlign())
        .nodeWidth(36)
        .nodePadding(40)
        .extent([[50, 20], [width - 50, height - 40]]);

      const {nodes, links} = sankey({
        nodes: rawNodes.map(d => ({...d})),
        links: rawLinks.map(d => ({...d}))
      });

      const color = d3.scaleOrdinal(d3.schemeCategory10);

      // Links
      const link = svg.append("g")
        .attr("fill", "none")
        .selectAll("path")
        .data(links)
        .join("path")
        .attr("d", d3.sankeyLinkHorizontal())
        .attr("stroke", d => color(d.source.name))
        .attr("stroke-width", d => Math.max(1, d.width))
        .attr("stroke-opacity", 0.5);

      link.append("title")
        .text(d => `${d.source.name} → ${d.target.name}: ${d.value}`);

      // Nodes
      const node = svg.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g");

      node.append("rect")
        .attr("x", d => d.x0)
        .attr("y", d => d.y0)
        .attr("height", d => Math.max(1, d.y1 - d.y0))
        .attr("width", d => d.x1 - d.x0)
        .attr("fill", d => color(d.name))
        .attr("stroke", "#000");

      node.append("text")
        .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
        .attr("y", d => (d.y1 + d.y0) / 2)
        .attr("dy", "0.35em")
        .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
        .text(d => d.name);

      node.append("title")
        .text(d => `${d.name}\nTotal flow: ${d.value.toFixed(1)}`);

      // Hover effects
      link.on("mouseover", function(event, d) {
          link.attr("stroke-opacity", l => l === d ? 1 : 0.1);
          node.select("rect").attr("opacity", n => (n === d.source || n === d.target) ? 1 : 0.3);
        })
        .on("mouseout", () => {
          link.attr("stroke-opacity", 0.5);
          node.select("rect").attr("opacity", 1);
        });

      node.on("mouseover", function(event, d) {
          link.attr("stroke-opacity", l => (l.source === d || l.target === d) ? 1 : 0.1);
          node.select("rect").attr("opacity", n => n === d ? 1 : 0.3);
        })
        .on("mouseout", () => {
          link.attr("stroke-opacity", 0.5);
          node.select("rect").attr("opacity", 1);
        });
    }

    function downloadPNG() {
      const svg = document.querySelector("#chart svg");
      if (!svg) return;

      const serializer = new XMLSerializer();
      let source = serializer.serializeToString(svg);
      source = source.replace(/<svg /, '<svg xmlns="http://www.w3.org/2000/svg" ');
      source = source.replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ');
      source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
      const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);

      const img = new Image();
      img.onload = function() {
        const canvas = document.createElement('canvas');
        canvas.width = 1200;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        const a = document.createElement('a');
        a.download = "alluvial-sankey-diagram.png";
        a.href = canvas.toDataURL("image/png");
        a.click();
      };
      img.src = url;
    }

    function loadAlluvialExample() {
      nodes = ["1990 Male", "1990 Female", "2000 Male", "2000 Female", "2010 Male", "2010 Female"];
      links = [
        {source: "1990 Male", target: "2000 Male", value: 45},
        {source: "1990 Male", target: "2000 Female", value: 5},
        {source: "1990 Female", target: "2000 Male", value: 3},
        {source: "1990 Female", target: "2000 Female", value: 48},
        {source: "2000 Male", target: "2010 Male", value: 42},
        {source: "2000 Male", target: "2010 Female", value: 6},
        {source: "2000 Female", target: "2010 Male", value: 4},
        {source: "2000 Female", target: "2010 Female", value: 47}
      ];
      document.getElementById('align').value = "Justify";
      rebuildNodesList();
      rebuildLinksTable();
      generate();
    }

    function loadEnergyExample() {
      nodes = ["Renewables", "Coal", "Gas", "Electricity", "Households", "Industry", "Transport", "Losses"];
      links = [
        {source: "Renewables", target: "Electricity", value: 25},
        {source: "Coal", target: "Electricity", value: 40},
        {source: "Gas", target: "Electricity", value: 35},
        {source: "Electricity", target: "Households", value: 40},
        {source: "Electricity", target: "Industry", value: 35},
        {source: "Electricity", target: "Transport", value: 15},
        {source: "Electricity", target: "Losses", value: 10}
      ];
      document.getElementById('align').value = "Center";
      rebuildNodesList();
      rebuildLinksTable();
      generate();
    }

    // Start with the alluvial example
    window.onload = loadAlluvialExample;
  </script>
</body>
</html>
